<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
    <entry key="node_file" type="xstring" value="settings.xml"/>
    <config key="flow_stack"/>
    <config key="internal_node_subsettings">
        <entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
    </config>
    <config key="model">
        <entry key="script" type="xstring" value="df &lt;- knime.in%%00010%%00010# get sequences w/o modifications%%00010sequence &lt;- colnames(df)[4:length(colnames(df))]%%00010sequence_wo_mod &lt;- sequence%%00010%%00010for (s in c(&quot;ac&quot;, &quot;me1&quot;, &quot;me2&quot;, &quot;me3&quot;, &quot;ph&quot;)) {%%00010%%00009sequence_wo_mod &lt;- gsub(s, &quot;&quot;, sequence_wo_mod)%%00010}%%00010%%00010#remove duplicated coeluting forms%%00010sequence_wo_mod &lt;- unname(sapply(sequence_wo_mod, function(x) {%%00010%%00009if (regexpr(&quot;/&quot;,x)!=-1) {%%00010%%00009%%00009x2 &lt;- substr(x, regexpr(&quot;_&quot;,x)+1, nchar(x))%%00010%%00009%%00009if (length(unique(strsplit(x2, &quot;/&quot;)[[1]])==1)) {%%00010%%00009%%00009%%00009substr(x, 1, regexpr(&quot;/&quot;,x)-1)%%00010%%00009%%00009} else {%%00010%%00009%%00009%%00009x%%00010%%00009%%00009}%%00010%%00009} else {%%00010%%00009%%00009x%%00010%%00009}%%00010}))%%00010%%00010# assign modifications to unmodified peptide sequence%%00010modification &lt;- tapply(sequence, sequence_wo_mod, function(x) x)%%00010mod_num &lt;-sapply(modification, length)%%00010%%00010# aggregation by modification type%%00010if (knime.flow.in$FormType==&quot;ac/me/ac+me/other&quot;) {%%00010%%00009ac_mod &lt;- lapply(modification, function(x) regexpr(&quot;ac&quot;,x)!=-1 &amp; regexpr(&quot;me&quot;,x)==-1)%%00010%%00009me_mod &lt;- lapply(modification, function(x) regexpr(&quot;me&quot;,x)!=-1 &amp; regexpr(&quot;ac&quot;,x)==-1)%%00010%%00009acme_mod &lt;- lapply(modification, function(x) regexpr(&quot;ac&quot;,x)!=-1 &amp; regexpr(&quot;me&quot;,x)!=-1)%%00010%%00009no_mod &lt;- lapply(modification, function(x) regexpr(&quot;ac&quot;,x)==-1 &amp; regexpr(&quot;me&quot;,x)==-1)%%00010} %%00010%%00010if (knime.flow.in$FormType==&quot;ac/other&quot;) {%%00010%%00009ac_mod &lt;- lapply(modification, function(x) regexpr(&quot;ac&quot;,x)!=-1)%%00010}%%00010%%00010if (knime.flow.in$FormType==&quot;me/other&quot;) {%%00010%%00009me_mod &lt;-lapply(modification, function(x) regexpr(&quot;me&quot;,x)!=-1)%%00010}%%00010%%00010# imputation%%00010if (knime.flow.in$replaceZeros==1) {%%00010%%00009check &lt;- sapply(modification, function(x) nrow(df) &gt; 2 * length(x))%%00010%%00009%%00010%%00009if (!all(check)) stop(&quot;Zeros can not be replaced for peptides: &quot;, paste(names(which(!check)), collapse=&quot;, &quot;), &quot;. The number of samples must be at least twice the number of forms.&quot;)%%00010%%00009## transformation to percentages with imputation for zeros%%00010%%00009relative_intensity &lt;- lapply(modification, function(i) {%%00010  %%00009%%00009temp &lt;- df[,i, drop=FALSE]%%00010  %%00009%%00009temp[temp==0] &lt;- NA%%00010  %%00009%%00009out &lt;- robCompositions::impCoda(tmp)$xImp%%00010  %%00009%%00009return(out)%%00010%%00009})%%00010%%00009%%00010} else {%%00010%%00009# transformation to percentages for each peptide%%00010%%00009peptide_sum &lt;- sapply(1:length(modification), function(i) {%%00010%%00009%%00009x &lt;- modification[[i]]%%00010%%00009%%00009if(length(x) &gt; 1) {%%00010%%00009%%00009%%00009rowSums(df[,x], na.rm=TRUE)%%00010%%00009%%00009} else {%%00010%%00009%%00009%%00009df[,x]%%00010%%00009%%00009}%%00010%%00009})%%00010%%00009colnames(peptide_sum) &lt;- names(modification)%%00010%%00009relative_intensity &lt;- Map(function(m,s) {%%00010%%00009%%00009out &lt;- (df[,m]/matrix(s, nrow=nrow(df), ncol=length(m))) * 100%%00010%%00009%%00009colnames(out) &lt;- m%%00010%%00009%%00009return(out)%%00010%%00009}, modification, data.frame(peptide_sum))%%00010}%%00010%%00010# aggregation of peptides%%00010if (knime.flow.in$FormType==&quot;ac/me/ac+me/other&quot;) {%%00010%%00009mod &lt;- lapply(seq_len(length(modification)), function(i) list(ac_mod[[i]], me_mod[[i]], acme_mod[[i]], no_mod[[i]]))%%00010%%00009relative_intensity &lt;- Map(function(r,s) {%%00010%%00009%%00009r &lt;- t(apply(r,1, function(x) sapply(s, function(m) sum(x[m], na.rm=TRUE)))) %%00010%%00009%%00009colnames(r) &lt;- c(&quot;acetylation&quot;, &quot;metylation&quot;, &quot;acetylation and metylation&quot;, &quot;other&quot;)%%00010%%00009%%00009r &lt;- as.data.frame(r)%%00010%%00009%%00009}, relative_intensity, mod)%%00010%%00009%%00010}  else if (knime.flow.in$FormType==&quot;ac/other&quot;) {%%00010%%00009# amalgamation of acetylated and not-acetylated forms%%00010%%00009relative_intensity &lt;- Map(function(r,s) {%%00010%%00009%%00009r &lt;- t(apply(r,1, function(x) tapply(x, s, sum, na.rm=TRUE)))%%00010%%00009%%00009if(nrow(r)==1) {%%00010%%00009  %%00009  r &lt;- t(r)%%00010%%00009  %%00009  if (s[1]) colnames(r)&lt;-&quot;acetylation&quot; else colnames(r)&lt;-&quot;other&quot;%%00010%%00009     } else {%%00010%%00009   %%00009  colnames(r)[colnames(r)==&quot;TRUE&quot;]&lt;-&quot;acetylation&quot;%%00010%%00009%%00009  colnames(r)[colnames(r)==&quot;FALSE&quot;]&lt;-&quot;other&quot;%%00010%%00009   %%00009}%%00010%%00009     return(as.data.frame(r))%%00010%%00009%%00009}, relative_intensity, ac_mod)%%00010} else if (knime.flow.in$FormType==&quot;me/other&quot;) {%%00010%%00009# amalgamation of metylated and not-metylated forms%%00010%%00009relative_intensity &lt;- Map(function(r,s) {%%00010%%00009%%00009r &lt;- t(apply(r,1, function(x) tapply(x,s, sum, na.rm=TRUE)))%%00010%%00009%%00009if(nrow(r)==1) {%%00010%%00009  %%00009  r&lt;-t(r)%%00010%%00009  %%00009  if (s[1]) colnames(r)&lt;-&quot;methylation&quot; else colnames(r)&lt;-&quot;other&quot;%%00010%%00009     } else {%%00010%%00009   %%00009  colnames(r)[colnames(r)==&quot;TRUE&quot;] &lt;- &quot;methylation&quot;%%00010%%00009%%00009  colnames(r)[colnames(r)==&quot;FALSE&quot;] &lt;- &quot;other&quot;%%00010%%00009   %%00009}%%00010%%00009     return(as.data.frame(r))%%00010%%00009%%00009}, relative_intensity, me_mod)%%00010}%%00010%%00010# functions for aggregation%%00010gmean &lt;- function(x)  {%%00010  y &lt;- x[!is.na(x) &amp; x&gt;0] %%00010  ifelse(length(y)==0, NA, prod(y)^(1/length(y)))%%00010}%%00010closecomp &lt;- function(x) {%%00010%%00009(x/sum(x[!is.na(x) &amp; x&gt;0]))*100%%00010}%%00010%%00010aggrep &lt;- function(x, group) {%%00009%%00010 agg &lt;- lapply(x, function(y) {%%00010  if (is.matrix(y)) y&lt;-as.data.frame(y)%%00010  if (nrow(y)==1) y&lt;-as.data.frame(t(y))%%00010  out&lt;-sapply(y, function(z) %%00010    tapply(z, factor(group, levels=unique(group)), gmean))%%00010  return(out)%%00010 })%%00010 %%00010 agg &lt;- lapply(agg, function(y) {%%00010 %%00009if (ncol(y)&gt;1) y&lt;-t(apply(y, 1, closecomp))%%00010 %%00009return(y)%%00010 %%00009}%%00010   )%%00010   %%00010 return(agg)  %%00010}%%00010%%00010# aggregation%%00010if (unique(df$Exp_design) != '' &amp;&amp; unique(df$Bio_rep) != '') {%%00010%%00009aggregation &lt;- paste(df$Exp_design, df$Bio_rep, sep = '_')%%00010} else if (unique(df$Exp_design != '')) {%%00010%%00009aggregation &lt;- df$Exp_design%%00010} else if (unique(df$Bio_rep != '')) {%%00010%%00009aggregation &lt;- df$Bio_rep%%00010} else {%%00010%%00009aggregation &lt;- df$Column%%00010}%%00010%%00010aggregated_intensity &lt;- aggrep(relative_intensity, aggregation)%%00010%%00010counter &lt;- unlist(lapply(seq_len(length(aggregation)), function (i) {%%00010%%00009if (i == 1) {%%00010%%00009%%00009return(1)%%00010%%00009} else {%%00010%%00009%%00009current &lt;- aggregation[i]%%00010%%00009%%00009sublist &lt;- aggregation[1:(i-1)]%%00010%%00009%%00009return(sum(sublist == current)+1)%%00010%%00009}%%00009%%00010}))%%00010%%00010# additional intensity list for statistical tests%%00010test_aggregation &lt;- paste(aggregation, counter, sep = '_')%%00010test_intensity &lt;- aggrep(relative_intensity, test_aggregation)%%00010%%00010# create list of pair comparisons%%00010if (knime.flow.in$CompType==&quot;All pairwise&quot;) {%%00010%%00009pair_comparisons &lt;- combn(unique(aggregation), 2)%%00010} else if (knime.flow.in[[&quot;CompType&quot;]] =='Experiment to control'){%%00010%%00009if (knime.flow.in$CompSpec == '') {%%00010%%00009%%00009stop('No experimental group provided')%%00010%%00009} else if (!(knime.flow.in$CompSpec %in% aggregation)) {%%00010%%00009%%00009stop('Experimental group not found')%%00010%%00009} else {%%00010%%00009%%00009pair_comparisons &lt;- t(expand.grid(unique(aggregation)[regexpr(knime.flow.in$CompSpec, unique(aggregation))==-1], %%00010%%00009%%00009%%00009%%00009%%00009%%00009%%00009%%00009    unique(aggregation)[regexpr(knime.flow.in$CompSpec, unique(aggregation))!=-1]))%%00010%%00009}%%00010} else {%%00010%%00009pair_comparisons &lt;- unlist(strsplit(knime.flow.in$CompSpec, ','))%%00010%%00009pair_comparisons &lt;- sapply(pair_comparisons, function(x) unlist(strsplit(x,&quot;-&quot;)))%%00010%%00009colnames(pair_comparisons) &lt;- NULL%%00010}%%00010%%00010pair_comparisons &lt;- as.data.frame(pair_comparisons)%%00010%%00010# functions to calculate p-values%%00010alr &lt;- function(x, var) {%%00010  t(t(log2(x[,- var]/x[, var])))%%00010}%%00010%%00010checkttest&lt;-function(x, y, g){%%00010%%00009out&lt;- c(&quot;&quot;)%%00010%%00009if (sum(!is.na(x) &amp; x!=0) &lt; knime.flow.in[[&quot;min_valid&quot;]] | length(x) &lt; knime.flow.in[[&quot;min_valid&quot;]]) {%%00010%%00009%%00009if (any(is.na(x))) valid&lt;-&quot;and missing&quot; else valid&lt;-&quot;&quot;%%00010%%00009%%00009out&lt;-paste(out, &quot;Few &quot;, valid, &quot; in &quot;,g[1],&quot; &quot;)%%00010%%00009}%%00010%%00009if (sum(!is.na(y) &amp; y!=0) &lt; knime.flow.in[[&quot;min_valid&quot;]] | length(y) &lt; knime.flow.in[[&quot;min_valid&quot;]]) {%%00010%%00009%%00009if (any(is.na(y))) valid&lt;-&quot;and missing&quot; else valid&lt;-&quot;&quot;%%00010%%00009%%00009out&lt;-paste(out, &quot;Few &quot;, valid, &quot; in &quot;,g[2],&quot; &quot;)%%00010%%00009}%%00010%%00009return(out)%%00010}%%00010%%00010# statistical comparison%%00010if (knime.flow.in[[&quot;FormType&quot;]] != 'all'){%%00010%%00009stat &lt;- lapply(seq_len(length(test_intensity)), function(i) {%%00010%%00009%%00009if (ncol(test_intensity[[i]]) &gt;1 ) {%%00010%%00009%%00009%%00009tmp &lt;- as.data.frame(compositions::ilr(test_intensity[[i]]))%%00010%%00009%%00009%%00009if (ncol(tmp)==0) {%%00010%%00009%%00009%%00009%%00009pt &lt;- rep(&quot;Only two forms&quot;, length(Pairs))%%00010%%00009%%00009%%00009} else {%%00010%%00009%%00009%%00009%%00009pt &lt;- sapply(pair_comparisons, function(g) {%%00010%%00009%%00009%%00009%%00009%%00009if (nrow(as.data.frame(tmp[aggregation %in% g,,drop=FALSE])) &lt;= ncol(as.data.frame(tmp[aggregation %in% g,, drop=FALSE]))) {%%00010%%00009%%00009%%00009%%00009%%00009%%00009&quot;Less samples than forms&quot; %%00010%%00009%%00009%%00009%%00009%%00009} else {%%00010%%00009%%00009%%00009%%00009%%00009%%00009as.numeric(try(Hotelling::hotelling.test(tmp[aggregation==as.character(g[1]),, drop=FALSE],%%00010%%00009%%00009%%00009%%00009%%00009%%00009%%00009%%00009 tmp[aggregation==as.character(g[2]),, drop=FALSE])$pval, silent=TRUE))%%00010%%00009%%00009%%00009%%00009%%00009}%%00010%%00009%%00009%%00009%%00009})%%00010%%00009%%00009%%00009}%%00010%%00009%%00009%%00009pt[is.na(pt)] &lt;- &quot;Singular covariance&quot;%%00010%%00009%%00009} else {%%00010%%00009%%00009%%00009pt &lt;- rep(&quot;Only one form&quot;, length(pair_comparisons))%%00010%%00009%%00009}%%00010%%00009%%00009%%00010%%00009%%00009if (is.null(nrow(pt))) pt &lt;- as.data.frame((pt))%%00010%%00009%%00009%%00010%%00009%%00009rownames(pt) &lt;- paste(unlist(pair_comparisons[1,,drop=FALSE]), unlist(pair_comparisons[2,,drop=FALSE]), sep=&quot;-&quot;)%%00010%%00009%%00009colnames(pt) &lt;- paste0(names(modification)[i], &quot;_globaltest&quot; )%%00010%%00009%%00009return(pt)%%00010%%00009})%%00010%%00009%%00010%%00009names(stat)&lt;-names(aggregated_intensity)%%00010%%00009%%00010} else if (knime.flow.in[[&quot;all_form_comp&quot;]] == 'individual forms') {%%00010%%00009stat &lt;- lapply(which(mod_num &gt; 1), function(i) {%%00010%%00009%%00009out &lt;- sapply(seq_len(ncol(test_intensity[[i]])), function(j) {%%00010%%00009%%00009%%00009w &lt;- colnames(test_intensity[[i]])==colnames(test_intensity[[i]])[j]%%00010%%00009%%00009%%00009dum &lt;- t(apply(test_intensity[[i]], 1, function(x) tapply(x, w, sum)))%%00010%%00009%%00009%%00009tmp &lt;- compositions::alr(dum)%%00010%%00009%%00009%%00009pt &lt;- sapply(pair_comparisons, function(g) {%%00010%%00009%%00009%%00009%%00009o&lt;-checkttest(tmp[pair_comparisons==as.character(g[1]),],%%00010%%00009%%00009%%00009%%00009       tmp[pair_comparisons==as.character(g[2]),], g)%%00010%%00009%%00009%%00009%%00009if (o==&quot;&quot;)  {%%00010%%00009%%00009%%00009%%00009%%00009as.numeric(try(t.test(tmp[aggregation==as.character(g[1]),], %%00010%%00009%%00009%%00009%%00009%%00009%%00009%%00009%%00009tmp[aggregation==as.character(g[2]),])$p.value, silent=TRUE)) %%00010%%00009%%00009%%00009%%00009} else {o}})%%00010%%00009%%00009     return(pt)%%00010  %%00009%%00009})%%00010  %%00009%%00009if (is.null(nrow(out))) out&lt;-as.data.frame(t(out))%%00010  %%00009%%00009rownames(out) &lt;- paste(unlist(pair_comparisons[1,,drop=FALSE]), unlist(pair_comparisons[2,,drop=FALSE]),sep=&quot;-&quot;)%%00010  %%00009%%00009colnames(out) &lt;- modification[[i]]%%00010  %%00009%%00009return(out)%%00010%%00009})%%00010%%00009%%00010} else {%%00010%%00009stat &lt;- lapply(which(mod_num&gt;1), function(i) {%%00010%%00009%%00009tmp &lt;- test_intensity[[i]]%%00010  %%00009%%00009pairs &lt;- combn(seq_len(ncol(tmp)),2)%%00010  %%00009%%00009transform &lt;- apply(pairs, 2, function(x) log2(tmp[,x[1]]/tmp[,x[2]]))%%00010  %%00009%%00009colnames(transform) &lt;- paste(modification[[i]][pairs[1,]], modification[[i]][pairs[2,]], sep=&quot;-&quot;)%%00010  %%00009  %%00009p &lt;- apply(transform, 2, function(x) {%%00010%%00009    %%00009%%00009sapply(pair_comparisons, function(g) {%%00010%%00009    %%00009%%00009%%00009o &lt;- checkttest(tmp[aggregation==as.character(g[1]),],%%00010%%00009%%00009%%00009%%00009%%00009       tmp[aggregation==as.character(g[2]),], g)%%00010%%00009%%00009%%00009%%00009%%00009if (o==&quot;&quot;) {%%00010%%00009%%00009%%00009%%00009%%00009%%00009as.numeric(try(t.test(x[aggregation==as.character(g[1])],%%00010%%00009           %%00009%%00009                 x[aggregation==as.character(g[2])])$p.value, silent=TRUE)) %%00010%%00009%%00009%%00009%%00009%%00009} else {%%00010%%00009%%00009%%00009%%00009%%00009%%00009o%%00010%%00009%%00009%%00009%%00009%%00009}%%00010%%00009    %%00009%%00009%%00009}%%00010    %%00009%%00009)})%%00010    %%00009%%00009if (is.null(nrow(p))) p &lt;-as.data.frame(t(p))%%00010  %%00009%%00009rownames(p)&lt;-paste(unlist(pair_comparisons[1,,drop=FALSE]), unlist(pair_comparisons[2,,drop=FALSE]), sep=&quot;-&quot;)%%00010  %%00009%%00009return(p)%%00010  %%00009})%%00010}"/>
        <entry key="templateUUID" type="xstring" isnull="true" value=""/>
        <entry key="version" type="xstring" value="version 1.x"/>
        <entry key="Output non numbers (NaN, Inf, -Inf) as missing cells" type="xboolean" value="false"/>
        <entry key="sendRowNames" type="xboolean" value="true"/>
        <entry key="sendBatchSize" type="xint" value="10000"/>
        <entry key="knimeInType" type="xstring" value="data.frame"/>
        <entry key="overwriteRHome" type="xboolean" value="false"/>
        <entry key="rHome" type="xstring" value="/home/knimeuser/.Renv/4.2.0/4.5.2a/lib/R"/>
        <entry key="useRPathHome" type="xboolean" value="true"/>
        <entry key="condaVariableName" type="xstring" isnull="true" value=""/>
    </config>
    <config key="variables">
        <entry key="version" type="xstring" value="V_2019_09_13"/>
        <config key="tree">
            <config key="rHome">
                <entry key="used_variable" type="xstring" value="Rcommand"/>
                <entry key="exposed_variable" type="xstring" isnull="true" value=""/>
            </config>
        </config>
    </config>
    <config key="nodeAnnotation">
        <entry key="text" type="xstring" value="perform statistical%%00010analysis"/>
        <entry key="bgcolor" type="xint" value="16777215"/>
        <entry key="x-coordinate" type="xint" value="1189"/>
        <entry key="y-coordinate" type="xint" value="499"/>
        <entry key="width" type="xint" value="142"/>
        <entry key="height" type="xint" value="32"/>
        <entry key="alignment" type="xstring" value="CENTER"/>
        <entry key="borderSize" type="xint" value="0"/>
        <entry key="borderColor" type="xint" value="16777215"/>
        <entry key="defFontSize" type="xint" value="10"/>
        <entry key="annotation-version" type="xint" value="20151123"/>
        <config key="styles"/>
    </config>
    <entry key="customDescription" type="xstring" isnull="true" value=""/>
    <entry key="state" type="xstring" value="IDLE"/>
    <entry key="factory" type="xstring" value="org.knime.r.TableToRNodeFactory"/>
    <entry key="node-name" type="xstring" value="Table to R"/>
    <entry key="node-bundle-name" type="xstring" value="KNIME R-Project nodes"/>
    <entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.r"/>
    <entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-bundle-version" type="xstring" value="4.6.0.v202205161326"/>
    <entry key="node-feature-name" type="xstring" value="KNIME Interactive R Statistics Integration"/>
    <entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.r.feature.group"/>
    <entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-feature-version" type="xstring" value="4.6.0.v202205161326"/>
    <config key="factory_settings"/>
    <entry key="name" type="xstring" value="Table to R"/>
    <entry key="hasContent" type="xboolean" value="false"/>
    <entry key="isInactive" type="xboolean" value="false"/>
    <config key="ports">
        <config key="port_1">
            <entry key="index" type="xint" value="1"/>
            <entry key="port_dir_location" type="xstring" isnull="true" value=""/>
        </config>
    </config>
    <config key="filestores">
        <entry key="file_store_location" type="xstring" isnull="true" value=""/>
        <entry key="file_store_id" type="xstring" isnull="true" value=""/>
    </config>
</config>
