<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
<entry key="node_file" type="xstring" value="settings.xml"/>
<config key="flow_stack"/>
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="script" type="xstring" value="# needs packages tidyr, robCompositions, compositions, hotelling%%00010rframe &lt;- knime.in%%00010names(rframe)%%00010# conversion to wide format%%00010library(tidyr)%%00010%%00010f&lt;-c(&quot;factor 1&quot;, &quot;factor 2&quot;, &quot;factor 3&quot;)%%00010f&lt;-f[f %in% colnames(rframe)]%%00010%%00010# tieto stlpce musia byt v datach. %%00010# Prvy je nazov stlpca s sekvenciu formy, druhy oznacenie replikatu, treti area%%00010#selectedNames&lt;-c(&quot;Sequence identificator&quot;, &quot;Replicate Name&quot;, &quot;Area sum&quot;) %%00010selectedNames&lt;-c(&quot;Sequence identifier&quot;, &quot;ColumnNames&quot;,&quot;ColumnValues&quot;)%%00010if (!all(selectedNames %in% colnames(rframe)))%%00010stop(&quot;The input table does not contain some or all of the required names:&quot;, selectedNames)%%00010%%00010rframe_wide &lt;- spread(rframe[,c(selectedNames, f)], selectedNames[1], selectedNames[3])%%00010%%00010#rframe_wide[1:2,] # check for transformation%%00010sekvence&lt;-colnames(rframe_wide)[-(1:(length(f)+1))]%%00010sekvence2&lt;-as.character(sekvence)%%00010%%00010#odstrani modifikacie z oznaceni sekvencie, mozno dopnit dalsie modifikacie%%00010#modifikacie jednej aminokyseliny piste dohromady napr:me1ac%%00010for (s in c(&quot;ac&quot;, &quot;me1&quot;, &quot;me2&quot;, &quot;me3&quot;, &quot;ph&quot;)) sekvence2&lt;-gsub(s, &quot;&quot;, sekvence2)%%00010%%00010#zapocitanie zdvojenych foriem%%00010sekvence2&lt;-sapply(sekvence2, function(x) {%%00010%%00009if (regexpr(&quot;/&quot;,x)!=-1) {%%00010%%00009%%00009x2&lt;-substr(x, regexpr(&quot;_&quot;,x)+1, nchar(x))%%00010%%00009%%00009if (length(unique(strsplit(x2, &quot;/&quot;)[[1]])==1)) substr(x, 1, regexpr(&quot;/&quot;,x)-1)%%00010%%00009%%00009} else x%%00009%%00010})%%00010%%00010%%00010modifikace&lt;-tapply(sekvence, sekvence2, function(x) x)%%00010modNum&lt;-sapply(modifikace, length)%%00010%%00010cat(&quot;Found following peptides and their forms\n&quot;)%%00010print(modifikace)%%00010%%00010if (any(modNum==1)) warning(paste0(&quot;Found peptides with only one modification type:&quot;, names(modifikace)[modNum==1]))%%00010%%00010%%00010# pomocne objekty pre aagregaciu podla typu modifikacie%%00010if (knime.flow.in$FormType==&quot;ac/me/ac+me/other&quot;) {%%00010%%00009acetylace&lt;-lapply(modifikace, function(x) regexpr(&quot;ac&quot;,x)!=-1 &amp; regexpr(&quot;me&quot;,x)==-1)%%00010%%00009metylace&lt;-lapply(modifikace, function(x) regexpr(&quot;me&quot;,x)!=-1 &amp; regexpr(&quot;ac&quot;,x)==-1)%%00010%%00009acetylacemetylace&lt;-lapply(modifikace, function(x) regexpr(&quot;ac&quot;,x)!=-1 &amp; regexpr(&quot;me&quot;,x)!=-1)%%00010%%00009bezmodifikace&lt;-lapply(modifikace, function(x) regexpr(&quot;ac&quot;,x)==-1 &amp; regexpr(&quot;me&quot;,x)==-1)%%00010} %%00010if (knime.flow.in$FormType==&quot;ac/other&quot;) {%%00010%%00009acetylace&lt;-lapply(modifikace, function(x) regexpr(&quot;ac&quot;,x)!=-1)%%00010}%%00010%%00010%%00010# doplnenie nul a chybajucich hodnot pre peptidy, u ktorych to je mozne. Potom prepocitane na percenta%%00010if (knime.flow.in$replaceZeros==1) {%%00010%%00009check&lt;-sapply(modifikace, function(m) nrow(rframe_wide)&gt;2*length(m))%%00010%%00009if (!all(check)) stop(&quot;Zeros can not be replaced for peptides: &quot;, paste(names(which(!check)), collapse=&quot;, &quot;), &quot;. The number of samples must be at least twice the number of forms.&quot;)%%00010%%00009## transformation to percentages with imputation for zeros%%00010%%00009relInt&lt;-lapply(modifikace, function(i) {%%00010  %%00009%%00009tmp&lt;-rframe_wide[,i, drop=FALSE]%%00010  %%00009%%00009tmp[tmp==0]&lt;-NA%%00010  %%00009%%00009out&lt;-robCompositions::impCoda(tmp)$xImp%%00010  %%00009%%00009return(out)%%00010%%00009%%00009})%%00010} else {%%00010%%00009# transformation to percentages for each peptide%%00010%%00009pepSum&lt;-sapply(modifikace, function(x) rowSums(rframe_wide[,x, drop=FALSE], na.rm=TRUE))%%00010%%00009relInt&lt;-Map(function(m,s) {%%00010%%00009%%00009out&lt;-(rframe_wide[,m]/matrix(s, nrow=nrow(rframe_wide), ncol=length(m)))*100%%00010%%00009%%00009colnames(out)&lt;-m%%00010%%00009%%00009return(out)%%00010%%00009}, modifikace, data.frame(pepSum))%%00010}%%00010%%00010# agregacia peptidov na jednotlive formy%%00010if (knime.flow.in$FormType==&quot;ac/me/ac+me/other&quot;) {%%00010%%00009mod&lt;-lapply(seq_len(length(modifikace)), function(i) list(acetylace[[i]], metylace[[i]], acetylacemetylace[[i]], bezmodifikace[[i]]))%%00010%%00009relInt&lt;-Map(function(r,s) {%%00010%%00009r&lt;-t(apply(r,1, function(x) sapply(s, function(m) sum(x[m], na.rm=TRUE)))) %%00010%%00009colnames(r)&lt;-c(&quot;acetylation&quot;, &quot;metylation&quot;, &quot;acetylation and metylation&quot;, &quot;other&quot;)%%00010%%00009r&lt;-as.data.frame(r)%%00010%%00009},relInt, mod)%%00010%%00009%%00010} %%00010if (knime.flow.in$FormType==&quot;ac/other&quot;) {%%00010%%00009# amalgamation of acetylated and not-acetylated forms%%00010%%00009relInt&lt;-Map(function(r,s) {%%00010%%00009%%00009r&lt;-t(apply(r,1, function(x) tapply(x,s, sum, na.rm=TRUE)))%%00010%%00009%%00009if(nrow(r)==1) {%%00010%%00009  %%00009  r&lt;-t(r)%%00010%%00009  %%00009  if (s) colnames(r)&lt;-&quot;acetylation&quot; else colnames(r)&lt;-&quot;other&quot;%%00010%%00009     } else {%%00010%%00009   %%00009  colnames(r)[colnames(r)==&quot;TRUE&quot;]&lt;-&quot;acetylation&quot;%%00010%%00009%%00009  colnames(r)[colnames(r)==&quot;FALSE&quot;]&lt;-&quot;other&quot;%%00010%%00009   %%00009}%%00010%%00009     return(as.data.frame(r))%%00010%%00009%%00009} ,relInt, acetylace)%%00010}%%00010%%00010if (knime.flow.in$FormType==&quot;all&quot;) {%%00010%%00009relInt&lt;-relInt%%00010}%%00010%%00010# functions for aggregation%%00010gmean&lt;-function(x)  {%%00010  y&lt;-x[!is.na(x) &amp; x&gt;0] %%00010  if (length(y)==0) NA else prod(y)^(1/length(y))%%00010  }%%00010closecomp&lt;-function(x) {(x/sum(x[!is.na(x) &amp; x&gt;0]))*100}%%00010%%00010aggrep&lt;-function(x, group) {%%00010 agg&lt;-lapply(x, function(rI) {%%00010  if (is.matrix(rI)) rI&lt;-as.data.frame(rI)%%00010  if (nrow(rI)==1) rI&lt;-as.data.frame(t(rI))%%00010  out&lt;-sapply(rI, function(ri) %%00010    tapply(ri, factor(group, levels=unique(group)), gmean))%%00010  return(out)%%00010 })%%00010 agg&lt;-lapply(agg, function(rI) {%%00010 %%00009if (ncol(rI)&gt;1) rI&lt;-t(apply(rI,1, closecomp))%%00010 %%00009return(rI)%%00010 %%00009}%%00010   )%%00010 return(agg)  %%00010}%%00010%%00010# check factors%%00010if (&quot;factor 1&quot; %in% f) {%%00010%%00009factor1&lt;-as.factor(rframe_wide[,&quot;factor 1&quot;])%%00010%%00009cat(paste0(&quot;factor 1 has the following levels: &quot;, paste(levels(factor1), collapse=&quot;, &quot;),&quot;\n&quot;, collapse=&quot;&quot;))%%00010}%%00010if (&quot;factor 2&quot; %in% f) {%%00010%%00009factor2&lt;-as.factor(rframe_wide[,&quot;factor 2&quot;])%%00010%%00009cat(paste0(&quot;factor 2 has the following levels: &quot;, paste(levels(factor2), collapse=&quot;, &quot;),&quot;\n&quot;, collapse=&quot;&quot;))%%00010}%%00010if (&quot;factor 3&quot; %in% f) {%%00010%%00009factor3&lt;-as.factor(rframe_wide[,&quot;factor 3&quot;])%%00010%%00009cat(paste0(&quot;factor 3 has the following levels: &quot;, paste(levels(factor3), collapse=&quot;, &quot;),&quot;\n&quot;, collapse=&quot;&quot;))%%00010}%%00010%%00010## THE FOLLOWING IS ASSUMED:%%00010## factor 1 = Technical Replicate%%00010## factor 2 = Experimental Group%%00010## factor 3 = Experiment/Order%%00010%%00010%%00010%%00010# aggregation%%00010Factor1&lt;-apply(rframe_wide[,f],1, function(x) paste(x, collapse=&quot;_&quot;))%%00010relIntAgg&lt;-aggrep(relInt, Factor1)%%00010%%00010%%00010if (&quot;factor 3&quot; %in% f) {%%00010%%00009factor23&lt;-paste(factor2, factor3, sep=&quot;_&quot;)%%00010} else {%%00010%%00009factor23&lt;-paste(factor2)%%00010}%%00010%%00010Factor23&lt;-tapply(factor23, Factor1, function(x) unique(x))%%00010Factor23&lt;-Factor23[rownames(relIntAgg[[1]])]%%00010%%00010relIntAggW&lt;-aggrep(relIntAgg, Factor23)%%00010%%00010%%00010# statistical analysis%%00010# vytvorenie parov pre porovnanie%%00010Factor23&lt;-factor(Factor23)%%00010if (knime.flow.in$CompType==&quot;All pairwise&quot;) {%%00010%%00009Pairs&lt;-combn(levels(Factor23),2)%%00010%%00009}%%00010%%00010if (knime.flow.in$CompType==&quot;Experiment to control&quot;){%%00010%%00009if (!any(regexpr(knime.flow.in$CompSpec, levels(Factor23))!=-1)) stop(&quot;The control group was not found. Possible groups are: &quot;, paste(levels(factor2), collapse=&quot;, &quot;))%%00010%%00009Pairs&lt;-t(expand.grid(levels(Factor23)[regexpr(knime.flow.in$CompSpec, levels(Factor23))==-1], %%00010%%00009%%00009%%00009%%00009%%00009 levels(Factor23)[regexpr(knime.flow.in$CompSpec, levels(Factor23))!=-1]))%%00010%%00009if (&quot;factor 3&quot; %in% f) {%%00010%%00009%%00009PairsE&lt;-substr(Pairs, regexpr(&quot;_&quot;, Pairs)+1, nchar(Pairs))%%00010%%00009%%00009PairsE&lt;-apply(PairsE,2, function(x) length(unique(x)))%%00010%%00009%%00009Pairs&lt;-Pairs[,PairsE==1]%%00009%%00010%%00009%%00009}%%00010}%%00010%%00010if (knime.flow.in$CompType==&quot;Selected&quot;) {%%00010%%00009Pairs&lt;-knime.flow.in$CompSpec%%00010%%00009Pairs&lt;-strsplit(Pairs, &quot;,&quot;)[[1]]%%00010%%00009Pairs&lt;-sapply(Pairs, function(x) strsplit(x,&quot;-&quot;)[[1]])%%00010%%00009#selecting all experiments with the two groups%%00010%%00009if (&quot;factor 3&quot; %in% f) {%%00010%%00009%%00009PairsE&lt;-separate(data.frame(levels(Factor23)), 1, c(&quot;Group&quot;, &quot;Exp&quot;), sep=&quot;_&quot;)%%00010%%00009%%00009Pairs&lt;-apply(Pairs, 2, function(x) {%%00010%%00009%%00009first&lt;-PairsE[PairsE[,1] %in% x[1],2]%%00010%%00009%%00009second&lt;-PairsE[PairsE[,1] %in% x[2],2]%%00010%%00009%%00009if (length(intersect(first, second))&gt;0) {%%00010%%00009%%00009%%00009tmp&lt;-expand.grid(x, intersect(first,second))%%00010%%00009%%00009%%00009matrix(unite(tmp, &quot;p&quot;, &quot;Var1&quot;, &quot;Var2&quot;, sep=&quot;_&quot;)$p,nrow=2)%%00010%%00009%%00009} else matrix(nrow=2)%%00010%%00009%%00009})%%00010%%00009Pairs&lt;-Pairs[,colSums(is.na(Pairs))==0,drop=FALSE]%%00010%%00009}%%00010%%00009%%00010}%%00010Pairs&lt;-as.data.frame(Pairs)%%00010cat(&quot;The following groups will be compared:\n&quot;)%%00010pp&lt;-as.matrix(Pairs)%%00010rownames(pp)&lt;-NULL; colnames(pp)&lt;-NULL%%00010print(t(pp))%%00010%%00010%%00010alr&lt;-function(x,ivar) {%%00010  t(t(log2(x[,-ivar]/x[,ivar])))%%00010}%%00010%%00010# vypocet p-hodnot%%00010LenMod&lt;-sapply(modifikace, function(x) length(x))%%00010if (knime.flow.in$CompGlob==1) {%%00010%%00009CompGlob&lt;-lapply(seq_len(length(relIntAgg)), function(i) {%%00010%%00009%%00009if (ncol(relIntAgg[[i]])&gt;1) {%%00010%%00009%%00009tmp&lt;-compositions::ilr(relIntAgg[[i]])%%00010%%00009%%00009if (ncol(tmp)==1) pt&lt;-rep(&quot;Only two forms&quot;, length(Pairs)) else%%00010%%00009%%00009pt&lt;-sapply(Pairs, function(g) {%%00010%%00009%%00009%%00009if (nrow(tmp[Factor23 %in% g,, drop=FALSE]) &lt;= ncol(tmp[Factor23 %in% g,, drop=FALSE])) &quot;Less samples than forms&quot; else %%00010%%00009%%00009%%00009as.numeric(try(Hotelling::hotelling.test(tmp[Factor23==as.character(g[1]),, drop=FALSE],%%00010%%00009%%00009%%00009                          tmp[Factor23==as.character(g[2]),, drop=FALSE])$pval, silent=TRUE))%%00010%%00009%%00009})%%00010%%00009%%00009pt[is.na(pt)]&lt;-&quot;Singular covariance&quot;%%00010%%00009%%00009} else pt&lt;-rep(&quot;Only one form&quot;, length(Pairs))%%00010%%00009%%00009if (is.null(nrow(pt))) pt&lt;-as.data.frame((pt))%%00010%%00009%%00009%%00010%%00009%%00009rownames(pt)&lt;-paste(unlist(Pairs[1,,drop=FALSE]), unlist(Pairs[2,,drop=FALSE]),sep=&quot;-&quot;)%%00010%%00009%%00009colnames(pt)&lt;-paste0(names(modifikace)[i], &quot;_globaltest&quot; )%%00010%%00009%%00009return(pt)%%00010%%00009})%%00010%%00009names(CompGlob)&lt;-names(relIntAgg)%%00010%%00009CompGlob%%00010%%00009%%00010} else CompGlob&lt;-lapply(seq_len(sum(LenMod&gt;1)), function(x) matrix(nrow=ncol(Pairs), ncol=0))%%00010%%00010checkttest&lt;-function(x,y, g){%%00010%%00009out&lt;-c(&quot;&quot;)%%00010%%00009if (sum(!is.na(x) &amp; x!=0)&lt;3 | length(unique(x))&lt;3) {%%00010%%00009%%00009if (any(is.na(x))) valid&lt;-&quot;and missing&quot; else valid&lt;-&quot;&quot;%%00010%%00009%%00009out&lt;-paste(out, &quot;Few &quot;, valid, &quot; in &quot;,g[1],&quot; &quot;)%%00010%%00009}%%00010%%00009if (sum(!is.na(y) &amp; y!=0)&lt;3 | length(unique(y))&lt;3) {%%00010%%00009%%00009if (any(is.na(y))) valid&lt;-&quot;and missing&quot; else valid&lt;-&quot;&quot;%%00010%%00009%%00009out&lt;-paste(out, &quot;Few &quot;, valid, &quot; in &quot;,g[2],&quot; &quot;)%%00010%%00009}%%00010%%00009return(out)%%00010}%%00010%%00010if (knime.flow.in$CompForm==1) {%%00010%%00009CompForm&lt;-lapply(which(LenMod&gt;1), function(i) {%%00010%%00009%%00009out&lt;-sapply(seq_len(ncol(relIntAgg[[i]])), function(j) {%%00010%%00009%%00009%%00009w&lt;-colnames(relIntAgg[[i]])==colnames(relIntAgg[[i]])[j]%%00010%%00009%%00009%%00009dum&lt;-t(apply(relIntAgg[[i]], 1, function(x)  tapply(x, w, sum)))%%00010%%00009%%00009%%00009tmp&lt;-compositions::alr(dum)%%00010%%00009%%00009%%00009pt&lt;-sapply(Pairs, function(g) {%%00010%%00009%%00009%%00009%%00009o&lt;-checkttest(tmp[Factor23==as.character(g[1]),],%%00010%%00009%%00009%%00009%%00009       tmp[Factor23==as.character(g[2]),], g)%%00010%%00009%%00009%%00009%%00009if (o==&quot;&quot;)        %%00010%%00009%%00009%%00009%%00009as.numeric(try(t.test(tmp[Factor23==as.character(g[1]),],%%00010%%00009%%00009%%00009%%00009       tmp[Factor23==as.character(g[2]),])$p.value, silent=TRUE)) else o})%%00010%%00009%%00009     return(pt)%%00010  %%00009%%00009})%%00010  %%00009%%00009if (is.null(nrow(out))) out&lt;-as.data.frame(t(out))%%00010  %%00009%%00009rownames(out)&lt;-paste(unlist(Pairs[1,,drop=FALSE]), unlist(Pairs[2,,drop=FALSE]),sep=&quot;-&quot;)%%00010  %%00009%%00009colnames(out)&lt;-modifikace[[i]]%%00010  %%00009%%00009return(out)%%00010%%00009%%00009})%%00010} else CompForm&lt;-lapply(seq_len(sum(LenMod&gt;1)), function(x) matrix(nrow=ncol(Pairs), ncol=0))%%00010%%00010%%00010if (knime.flow.in$CompPairs==1) {%%00010%%00009CompPairs&lt;-lapply(which(LenMod&gt;1), function(i) {%%00010%%00009%%00009tmp&lt;-relIntAgg[[i]]%%00010  %%00009%%00009pairs&lt;-combn(seq_len(ncol(tmp)),2)%%00010  %%00009%%00009R&lt;-apply(pairs, 2, function(x) log2(tmp[,x[1]]/tmp[,x[2]]))%%00010  %%00009%%00009colnames(R)&lt;-paste(modifikace[[i]][pairs[1,]],modifikace[[i]][pairs[2,]], sep=&quot;-&quot;)%%00010  %%00009  %%00009p&lt;-apply(R, 2, function(x) {%%00010    %%00009%%00009sapply(Pairs, function(g) {%%00010    %%00009%%00009%%00009o&lt;-checkttest(tmp[Factor23==as.character(g[1]),],%%00010%%00009%%00009%%00009%%00009       tmp[Factor23==as.character(g[2]),], g)%%00010%%00009%%00009%%00009%%00009if (o==&quot;&quot;) as.numeric(try(t.test(x[Factor23==as.character(g[1])],%%00010           %%00009%%00009                 x[Factor23==as.character(g[2])])$p.value, silent=TRUE)) else o%%00010    %%00009%%00009%%00009}%%00010    %%00009%%00009)})%%00010    %%00009%%00009if (is.null(nrow(p))) p&lt;-as.data.frame(t(p))%%00010  %%00009%%00009rownames(p)&lt;-paste(unlist(Pairs[1,,drop=FALSE]), unlist(Pairs[2,,drop=FALSE]),sep=&quot;-&quot;)%%00010  %%00009%%00009return(p)%%00010  %%00009})%%00010} else CompPairs&lt;-lapply(seq_len(sum(LenMod&gt;1)), function(x) matrix(nrow=ncol(Pairs), ncol=0))%%00010%%00010%%00010combinedResults&lt;-Map(function(x,y,z) {%%00010%%00009cbind(x,y,z)%%00010%%00009}, CompGlob, CompForm, CompPairs)%%00010%%00010combinedResults&lt;-Reduce(cbind, combinedResults)%%00010%%00010%%00010%%00010%%00010%%00010"/>
<entry key="templateUUID" type="xstring" isnull="true" value=""/>
<entry key="version" type="xstring" value="version 1.x"/>
<entry key="Output non numbers (NaN, Inf, -Inf) as missing cells" type="xboolean" value="false"/>
<entry key="sendRowNames" type="xboolean" value="true"/>
<entry key="sendBatchSize" type="xint" value="10000"/>
<entry key="knimeInType" type="xstring" value="data.frame"/>
</config>
<config key="nodeAnnotation">
<entry key="text" type="xstring" value="II's statistics%%00010(version 2021-04-07)"/>
<entry key="bgcolor" type="xint" value="16777215"/>
<entry key="x-coordinate" type="xint" value="677"/>
<entry key="y-coordinate" type="xint" value="287"/>
<entry key="width" type="xint" value="142"/>
<entry key="height" type="xint" value="34"/>
<entry key="alignment" type="xstring" value="CENTER"/>
<entry key="borderSize" type="xint" value="0"/>
<entry key="borderColor" type="xint" value="16777215"/>
<entry key="defFontSize" type="xint" value="10"/>
<entry key="annotation-version" type="xint" value="20151123"/>
<config key="styles"/>
</config>
<entry key="customDescription" type="xstring" isnull="true" value=""/>
<entry key="state" type="xstring" value="IDLE"/>
<entry key="factory" type="xstring" value="org.knime.r.TableToRNodeFactory"/>
<entry key="node-name" type="xstring" value="Table to R"/>
<entry key="node-bundle-name" type="xstring" value="KNIME R-Project nodes"/>
<entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.r"/>
<entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-bundle-version" type="xstring" value="4.1.1.v202001312017"/>
<entry key="node-feature-name" type="xstring" value="KNIME Interactive R Statistics Integration"/>
<entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.r.feature.group"/>
<entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-feature-version" type="xstring" value="4.1.1.v202001312017"/>
<config key="factory_settings"/>
<entry key="name" type="xstring" value="Table to R"/>
<entry key="hasContent" type="xboolean" value="false"/>
<entry key="isInactive" type="xboolean" value="false"/>
<config key="ports">
<config key="port_1">
<entry key="index" type="xint" value="1"/>
<entry key="port_dir_location" type="xstring" isnull="true" value=""/>
</config>
</config>
<config key="filestores">
<entry key="file_store_location" type="xstring" isnull="true" value=""/>
<entry key="file_store_id" type="xstring" isnull="true" value=""/>
</config>
</config>
